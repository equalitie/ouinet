#+title: Coding Ouinet

* Introduction

This document provides an overview of how the Ouinet source directory is structured, the main conventions and generic helper modules used in it, and the main Ouinet classes in the library and their roles.

Examples use ={{something}}= where the value of =something= should be placed, =(X|Y)= for either =X= or =Y=, =(X)?= for an optional =X=, and =(X)+= for a non-empty repetition of =X=.

*Note:* Links to source files and directories are relative to this document, while their texts are relative to the source code root.

*Note:* This is work in progress and intended as a very rough introduction to Ouinet source code, so expect some divergences between this document and the source.  Please contact mailto:ouinet@equalit.ie if you find misguiding content in this document, thanks!

* Directory structure

** Documentation

The [[file:.][=doc/=]] directory contains assorted documents about Ouinet:

- [[file:coding.org][=doc/coding.org=]]: this file
- [[file:ouinet-network-whitepaper.md][=doc/ouinet-network-whitepaper.md=]]: a technical description of how Ouinet works and its associated protocols; any implementation should ideally stick to this reference
- [[file:request-response-flow.svg][=doc/request-response-flow.svg=]]: a detailed diagram of how requests and responses travel over different Ouinet components (esp. within the client)
- [[file:android-sdk-versions.md][=doc/android-sdk-versions.md=]]: some clarifications on the chosen versions of Android SDK and API levels
- [[file:arch-drafts][=doc/arch-drafts/=]]: documents where particular parts of Ouinet specs are developed (they should but they might not match the white paper completely)

** Build system

Ouinet uses [[https://cmake.org/][CMake]] to build its source:

- [[file:../CMakeLists.txt][=CMakeLists.txt=]] is the main entry point to the CMake build configuration:
  - checks the version of CMake and some generic build flags
  - builds the Ouinet library and project-developed dependencies (included as submodules)
  - builds the client & injector programs
  - builds test programs and tools
- [[file:../cmake][=cmake/=]] contains more specific CMake configuration snippets:
  - [[file:../cmake/OuinetDependencies.cmake][=cmake/OuinetDependencies.cmake=]]: the build configuration of third-party dependencies (under the [[file:../cmake/dependencies][=cmake/dependencies/=]] subdirectory)
  - [[file:../cmake/BuildVersion.cmake][=cmake/BuildVersion.cmake=]]: machinery to extract the release version (from [[file:../version.txt][=version.txt=]], see below), compute a build identifier (=(Release|Debug) (HEAD|{{branch name}}) {{Git commit}}=), and make them available to source code

** Isolated build environments

Ouinet provides configuration files for different systems supporting isolated build environments, should you prefer not to pollute your main system with build dependencies:

- [[https://docker.io/][Docker]]: Files are provided to create a client/injector container image ([[file:../Dockerfile][=Dockerfile=]]), an image with dependencies to build the Android library ([[file:../Dockerfile.android][=Dockerfile.android=]]), and an image to run an Android emulator ([[file:../Dockerfile.android-emu][=Dockerfile.android-emu=]]). This is used for Docker Hub images. See [[file:../README.md][=README.md=]] for more information.
- [[https://vagrantup.com/][Vagrant]]: The [[file:../Vagrantfile][=Vagrantfile=]] can be used to build the Ouinet client, injector and tests. May be outdated. See [[file:../README.md][=README.md=]] for more information.
- [[https://guix.gnu.org/][GNU Guix]]: A Guix environment (either temporary or permanent) can be used to build the Ouinet client, injector and tests. See [[file:../guix/README.md][=guix/README.md=]] for more information.

** Scripts

The [[file:../scripts][=scripts/=]] directory contains scripts for assorted tasks:

- Building:
  - [[file:../scripts/build-ouinet-local.sh][=scripts/build-ouinet-local.sh=]] and [[file:../scripts/build-ouinet-git.sh][=scripts/build-ouinet-git.sh=]] can be invoked to build Ouinet from a local source checkout or from the Git repo (respectively) to =ouinet-local-build/= in the current directory.
  - [[file:../scripts/git-version-string.sh][=scripts/git-version-string.sh=]] is used by CMake to get versioning information from the Git checkout.
- Docker packaging:
  - [[file:../scripts/add-licenses-dir.sh][=scripts/add-licenses-dir.sh=]] includes dependency licensing information from [[file:../scripts/licenses][=src/licenses/=]] in the client/injector Docker container image.
  - [[file:../scripts/ouinet-wrapper.sh][=scripts/ouinet-wrapper.sh=]] acts as the container's entry point.
- Testing:
  - [[file:../scripts/run_integration_tests.sh][=scripts/run_integration_tests.sh=]] starts Ouinet's integration tests (see below). Outdated, not working currently.
  - [[file:../scripts/firefox-proxy.sh][=scripts/firefox-proxy.sh=]] runs Firefox with a temporary session which uses a local Ouinet client as its HTTP proxy. Outdated.
  - [[file:../scripts/ping-swarm][=scripts/ping-swarm=]] can be used to ping nodes announcing themselves in a Ouinet swarm on BitTorrent. See comments in the script for more information.

** Android support

The [[file:../android][=android/=]] directory contains files used to build the Ouinet library for Android (AAR):

- [[file:../android/build.gradle][=android/build.gradle=]] and [[file:../android/settings.gradle][=android/settings.gradle=]] are the main configuration files for [[https://gradle.org/][Gradle]], with files under [[file:../android/build-scripts][=android/build-scripts/=]] being used for handling the publication to [[https://search.maven.org/][Maven Central]].
- [[file:../android/i2pd][=android/i2pd/=]] contains support for the [[https://geti2p.net/][I2P]] transport. Probably outdated.
- [[file:../android/ouinet][=android/ouinet/=]] contains the JNI wrapper source for the Ouinet native library, plus the high level =Config= and =Ouinet= Java classes for running a Ouinet client in Android.

** Various source files and directories

- [[file:../docker-compose.yml][=docker-compose.yml=]] allows to run a Ouinet container (esp. for an injector) which can be easily managed and updated thanks to [[https://docs.docker.com/compose/][Docker Compose]]. See comments in the file for more information.
- [[file:../repos][=repos/=]] includes example configuration files for client and injector programs, used as their configuration templates by the Docker container image.
- [[file:../requirements.txt][=requirements.txt=]] includes Python dependencies for integration tests (see below). Outdated.
- [[file:../version.txt][=version.txt=]] contains the last stable version of Ouinet at or before the current Git commit. It follows [[https://semver.org/][Semantic Versioning]].
- [[file:../lib][=lib/=]] contains C++ files to enable building Boost ASIO and Boost ASIO SSL as dynamic libraries.
- [[file:../modules][=modules/=]] includes Git submodules for project-developed dependencies implementing Boost ASIO-compatible support for the [[https://en.wikipedia.org/wiki/Micro_Transport_Protocol][uTP]] and [[https://en.wikipedia.org/wiki/Universal_Plug_and_Play][UPnP]] protocols.
- [[file:../test][=test/=]] contains the source for unit tests (=test/test*.cpp=), integration tests ([[file:../test/integration_test][=test/integration_test/=]], outdated) and test tools (=test/bt-bep*.cpp= and =test/ouiservice-*.cpp=). Unit tests and test tools can be run standalone. The =bt-bep5= test tool is used by the =ping-swarm= script (see above).

** Main source directory

The [[file:../src][=src/=]] directory contains the main source code of the Ouinet library. Its files will be further discussed in following sections, though its overall structure is:

- [[file:../src/util][=src/util/=]]: generic, reusable code not specific to Ouinet protocols or formats.
- [[file:../src/parse][=src/parse/=]]: code which parses strings and yields other native C++ instances not specific to Ouinet.
- [[file:../src/ssl][=src/ssl/=]]: code to handle SSL/TLS connections (generic), certificate authorities, and end certificates (Ouinet-specific).
- [[file:../src/bittorrent][=src/bittorrent/=]]: implementation of BitTorrent protocols and formats, not specific to Ouinet.
- [[file:../src/ouiservice][=src/ouiservice/=]]: implementation of the different dynamic transports used for communication between Ouinet nodes. [[https://i2pd.website/][i2pd]] is included as a submodule in [[file:../src/ouiservice/i2p/i2pd][=src/ouiservice/i2p/i2pd/=]] (for the I2P transport).
- [[file:../src/cache][=src/cache/=]]: implementation of the protocols and formats specific to the Ouinet distributed cache.
- [[file:../src][=src/=]]: other Ouinet-specific code that does not belong in a specific subsystem. However, some code is actually not so Ouinet-specific, so it may belong in =src/util/= instead.

* Coding guidelines

- Ouinet follows the [[https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization][RAII]] principle when possible, making resource allocation and release significant. Use code blocks when necessary to control the scope and lifetime of objects.
- Genericity and reuse are encouraged. Prefer the use of templates when possible instead of extensive subclassing.
- Group names for related functionality under the same namespace under the ~ouinet~ namespace, even if they are declared in different places. Nesting of namespaces is ok if not too deep. If you need to have "non-public" declarations in a namespace defined in a header file, put them in a ~detail~ namespace under it.
- Ouinet makes extensive use of [[https://boost.org/][Boost]] libraries, especially [[https://www.boost.org/doc/libs/release/libs/asio/][Asio]] (for asynchronous programming), [[https://www.boost.org/doc/libs/release/libs/beast/][Beast]] (for everything HTTP), [[https://www.boost.org/doc/libs/release/libs/optional/][Optional]] and [[https://www.boost.org/doc/libs/release/libs/filesystem/][Filesystem]].
- Indentation style is not very strict nor consistent, but this snippet will give you a general idea:

#+begin_src c++
#include "logger.h"

namespace ouinet {
namespace foo {

template<class X>
static
int
bar_stuff( const X& x
         , Something s)
{
    if (s.blah())
        return 42;

    if (s.unstable()) {
        LOG_WARN("Got an unstable something: ", s);
        return 23;
    }

    return std::frobnicate( x.to_frobnicate()
                          , s.can_frobnicate()
                            ? s.to_frobnicate()
                            : 123);
}

} // namespace foo
} // namespace ouinet
#+end_src

** Boost namespaces

Since the use of Boost types, values and functions is so pervasive in Ouinet, some Boost namespaces are given shorthands in the ~ouinet~ namespace. For instance, ~boost::filesystem~ is aliased to ~ouinet::fs~, so that ~fs::path~ can be used instead of ~boost::filesystem::path~ in Ouinet code. To use such shorthands, [[file:../src/namespaces.h][=src/namespaces.h=]] is included.

** Concurrency

In Ouinet, with the exception of code run at the very beginning of programs, or trivial I/O (like with small state files), all operations which may wait for I/O or other events are implemented as concurrent /asynchronous functions/ or /coroutines/ using [[https://www.boost.org/doc/libs/release/libs/asio/][Boost Asio]].

Coroutines can be recognized for having an argument of type ~boost::asio::yield_context~ (usually called ~yield~ or ~y~), which is first received from a ~boost::asio::spawn~ call; see [[file:../src/injector.cpp::listen(config, proxy_server, cancel, yield][injector listen spawn]] and [[file:../src/injector.cpp::void listen(][injector listen op]] for an example. *Note:* Those show a common pattern where listening for incoming connections happens as a coroutine, while handling each such connection happens in its own coroutine; see [[file:../src/injector.cpp::serve( config][injector serve op]].

The execution of coroutines begins when ~boost::asio::io_context~'s ~run()~ is invoked; see [[file:../src/client.cpp::ctx.run();][client main]] for an example. A coroutine will run until it returns or throws an exception; the [[file:../src/util/handler_tracker.h::define TRACK_SPAWN(exec,][~TRACK_SPAWN~]] macro can be used instead of ~spawn~ to catch and report exceptions from the coroutine (avoiding a crash), and to report if it fails to stop on program exit (implemented in [[file:../src/util/handler_tracker.cpp::void stop() {][handler tracker stop]]); see [[file:../src/client.cpp::void Client::State::start()][client start]] for an example of tracking the concurrent start of several coroutines.

** Error handling

Coroutines can signal an error either by throwing an ~std::runtime_error~ if they receive a plain ~yield_context~ (like ~yield~), or by changing a ~boost::system::error_code~ passed to the ~yield_context~ (like ~yield[ec]~). The preferred way to handle errors in Ouinet is to get them in an ~error_code~ to avoid unhandled exceptions (which also cause extra issues with address sanitizers and coroutines):

#+begin_src c++
sys::error_code ec;
do_something(arg1, arg2, yield[ec]);
if (ec) { /* handle error */ }
#+end_src

To simplify the proper signaling of errors in Ouinet coroutines, they use the ~ouinet::or_throw~ functions in [[file:../src/or_throw.h][=src/or_throw.h=]], which take care of using the error behavior expected by the caller:

#+begin_src c++
#include "namespaces.h"
#include "or_throw.h"

namespace ouinet {

int
get_foo(asio::yield_context yield)
{
    // Do something.
    if ( /* some error condition */ )
        return or_throw(yield, asio::error::invalid_argument, 0);
        // Or with default return value construction:
        //return or_throw<int>(yield, asio::error::invalid_argument);
    return 42;
}

}  // namespace ouinet
#+end_src

You may also use ~or_throw~ when there is no error:

#+begin_src c++
int
get_bar(asio::yield_context yield) {
    sys::error_code ec;
    int ret = get_foo(yield[ec]);
    // Pass return value and error (if any) upwards.
    return or_throw(yield, ec, ret);
}
#+end_src

** Logging and string conversion

Ouinet uses a very simple logging infrastructure available in [[file:../src/logger.h][=src/logger.h=]]. It provides [[file:../src/logger.h::enum log_level_t][log level constants]] (the lower, the more verbose), a global ~logger~ singleton instance mostly used to get or set the log level, and some ~LOG_{{LEVEL}}~ [[file:../src/logger.h::define LOG_SILLY][macros]] to log at levels equal or lower than =LEVEL= using ~logger~. In contrast with the rest of the Ouinet library, these declarations live in the root namespace, with no prefixes either (this may change in the future). Log messages use color codes (except on Android) and can include time stamps (currently unused).

Some implementation files define ~_{{LEVEL}}~ macros on top of ~_LOG_{{LEVEL}}~ ones to include a common, specific prefix (defined as ~_LOGPFX~) in every message logged from there (as in [[file:../src/bittorrent/dht.cpp::define _LOGPFX][BitTorrent DHT code]]).

Logging macros convert their arbitrary arguments to ~std::string~ objects using ~ouinet::util::str~ (from [[file:../src/util/str.h][=util/str.h=]]), which works for any type which can be serialized to an ~std::ostream~ using ~operator<<~. Some frequently-logged values like ~boost::system::error_code~ and ~boost::beast::http::status~ are pretty-printed by ~str~.

For example, to log an error result from an operation:

#+begin_src c++
#include "logger.h"

// ...
sys::error_code ec;
do_foo(bar, yield[ec]);
if (ec) {
    LOG_ERROR("Failed to foo: ", bar, "; ec=", ec);
    return or_throw(yield, ec);
}
// ...
#+end_src

That may produce =[ERROR] Failed to foo: SomeBar; ec=​"Invalid argument"=.

In general, the format used for log messages is ={{Message}}(: {{object}})?((...|: {{status}}))?(;( {{key}}={{value}})+)?=, where:

- =Message= is a capitalized sentence with no period, e.g. =Failed to foo=.
- =object= is not quoted, e.g. =http://example.com/=.
- =status= may be something like =failed= or =done=, to indicate the result of an operation whose start was logged previously with the same =Message= and an =...= ellipsis after it (as when [[file:../src/cache/client.cpp::_DEBUG("Collecting garbage...");][collecting garbage from the local cache]]).
- =key= is short and without spaces (e.g. =ec= for an error code) and =value= is double-quoted if it contains spaces.

Some ~boost::asio::error::operation_aborted~ errors are not reported to avoid cluttering the log with many messages of canceled operations when a program is terminated (as when [[file:../src/client.cpp::LOG_ERROR("Failed to set up Bep5Client at setting up BT DHT; ec=", ec);][setting up the client's BitTorrent DHT]]).

** Deferred actions

Another example of RAII in action is provided by [[file:../src/defer.h][=src/defer.h=]]. Calling ~ouinet::defer~ with a function returns a ~Defer~ object which runs the function as soon as the object is deallocated. Besides for doing cleanup (as in [[file:../src/util/persistent_lru_cache.h::auto on_exit = defer][persistent LRU cache load]]), this is frequently used to report the result of a series of operations regardless of how they finish (as in [[file:../src/bittorrent/dht.cpp::auto report = defer][BitTorrent DHT contacts store]]); you just need to make sure that the data to be reported is always set, like the error code below:

#+begin_src c++
#include "logger.h"
#include "namespaces.h"
#include "util/defer.h"

// ...
LOG_DEBUG("Doing foo...");
sys::error_code ec;
auto log_result = defer([&ec] {
    LOG_DEBUG("Doing foo: done; ec=", ec);
});
// Operations which set "ec"...
#+end_src

** Cancellation signaling

When a coroutine is spawned, the caller code loses track of it. However, it may want to send a signal to such coroutines for them to take some action, like canceling whatever operation they are carrying (e.g. because it is taking too long, or the user explicitly aborted it, or the program was told to terminate).

In [[file:../src/util/signal.h][=src/util/signal.h=]], Ouinet defines the [[file:../src/util/signal.h::class Signal][~Signal~]] class. Function objects can be /connected/ to the signal using ~connect~, and they are called when the signal is /triggered/ with ~operator()~. Arguments passed to the trigger call are forwarded to the connected functions. The connection between signal and function only lasts while the result of ~connect~ is kept alive. A signal evaluates to a ~true~ Boolean once triggered, otherwise to ~false~.

When a signal is initialized from another one (via copy constructor or ~operator=~), the former becomes a /child/ of the later /parent/ signal. Triggering the parent signal causes its children to be triggered too, while triggering a child signal does not trigger its parent. Thus, signals form inverted trees where triggering only flows recursively downwards.

A child signal can have its own connected functions, also called on signal trigger.

~Cancel~ is just a signal with no trigger arguments, conventionally used to indicate that the current operation must be aborted. The following code spawns a coroutine which eventually gets a cancellation signal, closing the ~foo~ object and causing ~do_something~ to terminate. ~mutable~ is needed here because the ~child_cancel~ captured variable is changed in the function.

#+begin_src c++
#include "namespaces.h"
#include "or_throw.h"
#include "signal.h"

// ...
Cancel cancel;
TRACK_SPAWN( executor  // the macro catches and reports errors
           , [child_cancel = cancel] (asio::yield_context yield) mutable {
    Foo foo;
    auto close_slot = child_cancel.connect({ foo.close(); });  // keep alive
    sys::error_code ec;
    do_something(foo, yield[ec]);
    if (child_cancel) ec = asio::error::operation_aborted;
    if (ec) return or_throw(yield, ec);
    // Non-error stuff...
});
// ...
cancel();
// ...
#+end_src

If cancellation happens, ~boost::asio::error:operation_aborted~ is reported, no matter what the outcome from ~do_something~ is. This is a very frequent idiom in Ouinet; to avoid the boilerplate, =signal.h= provides the [[file:../src/util/signal.h::compute_error_code( const sys::error_code&][~compute_error_code(ec, cancel)~]] function and the [[file:../src/util/signal.h::define return_or_throw_on_error(][~return_or_throw_on_error(yield, cancel, ec, ...)~]] macro. Thus, the error handling code above may be replaced by:

#+begin_src c++
do_something(foo, yield[ec]);
ec = compute_error_code(ec, child_cancel);
if (ec) {
    if (ec != asio::error::operation_aborted)  // avoid noise on program termination
        LOG_ERROR("Failed to do something; ec=", ec);
    return or_throw(yield, ec);
}
// Non-error stuff...
#+end_src

or, without the logging, just:

#+begin_src c++
do_something(foo, yield[ec]);
return_or_throw_on_error(yield, child_cancel, ec);
// Non-error stuff...
#+end_src

If both caller and callee coroutines support cancellation, it is usual to pass the cancellation signal to the call. The callee will either get a child signal directly (with pass-by-value, as in [[file:../src/cache/http_store.cpp::auto sz = HttpReadStore::size(cancel, yield][HTTP static store size computation]]), or create the child signal itself (with pass-by-reference, as in [[file:../src/bittorrent/dht.cpp::bool dht::DhtNode::query_find_node2(][BitTorrent DHT node find]]).

Some classes sport a /lifetime cancellation signal/ triggered on instance destruction; instance methods which allow a cancellation signal parameter connect the former to the triggering the of later (as in [[file:../src/util/async_queue.h::void async_wait_for_push(][async queue wait for push]]). The result of this is that code owning the instance can force the cancellation of all its running operations simply by destroying it. The general pattern is:

#+begin_src c++
#include "namespaces.h"
#include "signal.h"

class Foo {
public:
    // ...
    void
    do_stuff(Cancel cancel, asio::yield_context yield) {
        auto slot = _lifetime_cancel.connect([&] { cancel(); });
        // ...
    }

    ~Foo() {
        _lifetime_cancel();
    }

private:
    // ...
    Cancel _lifetime_cancel;
};
#+end_src

** Extended yield contexts

Due to its heavy use of coroutines, Ouinet defines in [[file:../src/util/yield.h][=src/util/yield.h=]] the ~ouinet::Yield~ class, which mimics ~boost::asio::yield_context~ and its ~yield[error_code]~ semantics, while adding the following features:

- Tracking of parent/child relationships established when creating a ~Yield~ instance from another one.
- A textual tag like =({{optional prefix}}/)?R{{unique id}}= for top-level instances, with each child having an optional, custom tag which extends its parent's, like ={{parent tag}}/{{child tag}}/{{grandchild tag}}=.
- Automatic warnings (including the tag) every 30 seconds if the associated coroutine is still running.
- A [[file:../src/util/yield.h::void log(log_level_t][~log~]] method which reports a message as ={{tag}}: {{message}}= (for a given log level).

~Yield~ instances can be created in several ways:

- Top-level: with one of the [[file:../src/util/yield.h::Yield( asio::io_context&][constructors]] receiving just a ~yield_context~ (as in the [[file:../src/client.cpp::Yield yield(_ctx, yield_, "frontend");][client front-end acceptor]]). In Ouinet, it is common to associate each top-level instance with an HTTP request/response in a connection, using =C{{connection id}}= as a common prefix (as in [[file:../src/client.cpp::Yield yield(_ctx.get_executor(), yield_, connection_idstr);][client connection serve]] or [[file:../src/injector.cpp::Yield yield(con.get_executor(), yield_, util::str('C', connection_id));][injector connection serve]]).
- Children: over an existing ~Yield~ instance, either using a [[file:../src/util/yield.h::Yield(Yield& parent)][copy constructor]] or [[file:../src/util/yield.h::Yield operator\[\]][~operator[]~]] (as in all functions getting a ~Yield~ parameter by value, and in [[file:../src/injector.cpp::auto stream = connect(rq_, cancel, yield\[ec\].tag("connect"));][injector get connection]], respectively; the child uses its parent's tag), or with the [[file:../src/util/yield.h::Yield tag(std::string t)][~tag("something")~]] method (as in [[file:../src/cache_control.cpp::auto ryield = yield.tag("force_reval");][cache control fetch]] and [[file:../src/injector.cpp::auto stream = connect(rq_, cancel, yield\[ec\].tag("connect"));][injector get connection]]; the child uses the tag ={{parent tag}}/something=).
- Detached children: from an existing ~Yield~ instance plus a new ~yield_context~, with the [[file:../src/util/yield.h::Yield detach(asio::yield_context yield)][~detach~]] method (e.g. when spawning a new coroutine from the current one, as in [[file:../src/client.cpp::yield.detach(yield_)\[ec\].run(\[&\] (auto y) {][client store to cache]]).

To avoid the inadvertent loss of features like tags and tracking, ~Yield~ instances need to be explicitly converted to ~yield_context~ when only the later is allowed or desired, by using ~static_cast<asio::yield_context>~ (as when [[file:../src/client.cpp::async_sleep(exec, delay, c, static_cast<asio::yield_context>(yield));][making this pause]]). To ease tagging and tracking operations which do not support ~Yield~, those may be wrapped in a call to the [[file:../src/util/yield.h::run(F&& f)][~run~]] method, which keeps the ~Yield~ instance alive (as in the [[file:../src/client.cpp::Yield yield(_ctx, yield_, "frontend");][client front-end acceptor]]). In the following example ~y~ is a plain ~yield_context~ which is already setting ~ec~ (so there is no need to write ~y[ec]~):

#+begin_src c++
#include "namespaces.h"
#include "util/yield.h"

namespace ouinet {

int do_foo(asio::yield_context);

int
do_bar(Yield yield)
{
    sys::error_code ec;
    int x = yield[ec].tag("foo").run([] (auto y) {
        return do_foo(y);
    });
    yield.log(LOG_DEBUG, "Did foo; ec=", ec);
    return or_throw(yield, ec, x);
}

}  // namespace ouinet
#+end_src

Since the ~yield.log(LOG_{{LEVEL}}, ...)~ syntax can become verbose, some implementation files define ~_Y{{LEVEL}}(yield, ...)~ macros (as in [[file:../src/client.cpp::define _YDEBUG][client code]]).

* Generic support code

TODO

** Synchronization mechanisms

As mentioned in [[*Cancellation signaling][Cancellation signaling]], parent code which spawns a coroutine loses track of it, so special mechanism are needed to interact with such coroutines. The main mechanisms provided by Ouinet are:

- *Watchdogs:* Available from [[file:../src/util/watch_dog.h][=src/util/watch_dog.h=]], [[file:../src/util/watch_dog.h::watch_dog(const asio::][~ouinet::watch_dog~]] creates an object with a given associated timeout duration and function. If the watchdog is still alive after the duration, the function is called and the watchdog's ~is_running~ method starts returning ~false~.

  A watchdog can be disabled with its ~stop~ method and enabled again with a new timeout and function with the ~start~ method (then ~is_running~ returns ~true~ again).

  Watchdogs are used to cancel operations which do not finish within a given time, either by triggering a child cancellation signal:

  #+begin_src c++
  Cancel timeout_cancel(cancel);
  auto wd = watch_dog( executor, timeout
                     , [&timeout_cancel] { timeout_cancel(); });
  do_something(timeout_cancel, yield[ec]);
  #+end_src

  or by altering some object in a way that causes operations on it to stop working immediately:

  #+begin_src c++
  auto wd = watch_dog( executor, timeout
                     , [&stream] { stream.close(); });
  consume(stream, yield[ec]);
  #+end_src

  Ouinet follows the convention of reporting ~boost::asio::error::timed_out~ when an operation was canceled because of a watch dog triggering on timeout, unless some parent cancellation was triggered too. Again, to avoid the boilerplate of figuring out the proper error, =watch_dog.h= provides an extended [[file:../src/util/watch_dog.h::compute_error_code( const sys::error_code][~compute_error_code(ec, cancel, watchdog)~]] function and a [[file:../src/util/watch_dog.h::define fail_on_error_or_timeout][~fail_on_error_or_timeout(yield, cancel, ec, watchdog, ...)~]] macro.  See [[file:../src/injector.cpp::if (ec = compute_error_code(ec, cancel, fetch_wd)) {][injector signed fetch]] and [[file:../src/client.cpp::fail_on_error_or_timeout(yield, cancel, ec, watch_dog, CacheEntry{});][client cache fetch]] for respective examples of both; please note how the parent cancellation signal is checked to consider upstream cancellation instead of the child signal, which would cause timeouts to be reported as cancellations.

- *Condition variables:* Defined in [[file:../src/util/condition_variable.h::class ConditionVariable][=src/util/condition_variable.h=]]: this mechanism waits for a coroutine until it reports that its operation has finished. Internally, ~ConditionVariable~ is an intrusive list of [[file:../src/util/condition_variable.h::struct WaitEntry][~WaitEntry~]] structs and some control methods like [[file:../src/util/condition_variable.h::void ConditionVariable::notify][~notify~]] and [[file:../src/util/condition_variable.h::void ConditionVariable::wait][~wait~]].

  The main constructor of ~ConditionVariable~ receives an executor as a parameter. After its initialization, it can be put into standby using ~wait~ until ~notify~ is invoked by a finished task.

  #+begin_src c++
  ConditionVariable cv(executor);

  spawn(executor, [&cv] (auto yield) {
      do_something(yield);
      cv.notify();
  });

  cv.wait(yield);
  #+end_src

  An example of its usage can be found in [[file:../src/cache_control.cpp::ConditionVariable cv(_ex);][=src/cache_control.cpp=]] where the ~WaitCondition~ is used to wait for the completion of fetch tasks.

  ~ConditionVariable~ is also used by [[file:../src/util/wait_condition.h::ConditionVariable][~WaitCondition~]] and [[file:../src/util/success_condition.h::ConditionVariable][~SuccessCondition~]] (described below) as part of their ~WaitState~ struct.

- *Wait conditions:* Defined in [[file:../src/util/wait_condition.h::class WaitCondition][=src/util/wait_condition.h=]], [[file:../src/util/wait_condition.h::class WaitCondition][~ouinet::WaitCondition~]] implements a mechanism to wait for all the members of a group of coroutines to finish a task. To achieve this, the ~WaitCondition~ keeps a counter of the locks that are held by the coroutines, and when the coroutines are done they may either release the lock explicitly, or automatically when the lock is destroyed. When the [[file:../src/util/wait_condition.h::return _wait_state->remaining_locks;][~remaining_locks~]] counter reaches zero, the [[file:../src/util/wait_condition.h::struct WaitState][~WaitState~]] is changed and the ~WaitCondition~ is over.

  A ~WaitCondition~ object should be initialized with an executor. After that, the result of ~wait_condition.lock~ can be attached to each spawned coroutine (e.g. via a lambda capture). Finally, the ~wait_condtion.wait~ method should be invoked to wait for all the tasks to finish:

  #+begin_src c++
  WaitCondition wait_condition(executor);
  spawn(executor, [lock = wait_condition.lock()] (auto yield) {
      do_something(yield);
  }
  wait_condition.wait(yield);
  #+end_src

  There is an example of ~WaitCondition~ in [[file:../src/client.cpp::WaitCondition wait_condition(_ctx);][=src/client.cpp=]] where ~wait_condition.lock~ and ~wait_condition.wait~ are used [[file:../src/client.cpp::wait_condition.wait(yield)][to wait]] for the active sockets to finish before terminating the incoming TCP connection.

- *Success conditions:* Available from [[file:../src/util/success_condition.h::class SuccessCondition][=src/util/success_condition.h=]], this mechanism is similar to ~WaitCondition~ with two main differences; the first one is that ~SuccessCondition~ waits until one of the coroutines finishes with a task [[file:../src/util/success_condition.h::if (success) {][successfully]] or when all of them finish [[file:../src/util/success_condition.h::Lock::~Lock][unsuccessfully]], the second difference is that the mechanism implements a [[file:../src/util/success_condition.h::void SuccessCondition::cancel()][~cancel method~]].

  ~SuccessCondition~ objects are also initialized with an executor and its locks are also attached to each spawned coroutine, with the difference that reaching a destructor implies unsuccessful completion:

  #+begin_src c++
  SuccessCondition success_condition(executor);

  spawn(executor, [lock = success_condition.lock()] (auto yield) {
      if (!do_something(yield)) {
          // Lock destructor implies unsuccessful completion.
          return;
      }
      // Operation finished successfully.
      lock.release(true);
  });

  // Returns when one of the two coroutines has called release(true),
  // OR all of them have failed.
  success_condition.wait_for_success(yield);
  #+end_src

  There is an example of usage in [[file:../src/ouiservice.cpp::SuccessCondition success_condition(_ex);][=src/ouiservice.cpp=]] where the ~SuccessCondition~ is waiting for at least one successful start of any of the possible implementations supported by the ~OuiServiceServer~.

- *Asynchronous jobs:* The [[file:../src/util/async_job.h][=src/util/async_job.h=]] header defines the ~AsyncJob~ class, which wraps the spawning of a cancellable coroutine returning a result (~start~ method), and allows the caller to wait for or react to its completion (~wait_for_finish~ and ~on_finish_sig~ methods), retrieve its result (~result~ methods), and cancel it explicitly (~cancel~ method) or implicitly on deallocation.

  #+begin_src c++
  AsyncJob<SomeResult> job(executor);
  job.start([] (Cancel& c, asio::yield_context y) -> SomeResult {
      sys::error_code ec;
      SomeResult result = do_something(c, y[ec]);
      ec = compute_error_code(ec, c);
      return or_throw(y, ec, std::move(result));
  });

  if (some_condition())
      return;  // cancels the job automatically

  sys::error_code ec;
  job.wait_for_finish(yield[ec]);
  if (!ec && job.has_result()) {
      SomeResult result = job.result();
      do_something_with_result(result);
  }
  #+end_src

  You can see examples of waiting for job completion in [[file:../src/cache/multi_peer_reader.cpp::struct MultiPeerReader::PreFetchParallel : MultiPeerReader::PreFetch {][multi-peer reader parallel block fetching]] (~get_block~ method), and reacting to job completion in [[file:../src/client.cpp::jc = origin.on_finish_sig(\[&c\] { c(); });][client request job start]] (where a cancellation signal is triggered to abort a sleep operation started further down).

TODO

** Connections and streams

TODO

** File operations

TODO

** HTTP response handling

TODO

** Cache control

The Ouinet distributed cache tries to work as much as possible as a standard HTTP cache. To decouple HTTP caching algorithms from dynamic transports and distributed storage, [[file:../src/cache_control.h][=src/cache_control.h=]] provides the ~ouinet::CacheControl~ class with all the machinery to decide when to use fresh or cached resources, while making fresh and cached retrieval operations customizable. It implements the HTTP Caching RFCs [[https://www.rfc-editor.org/rfc/rfc7234.html][7234]], [[https://www.rfc-editor.org/rfc/rfc5861.html][5861]] and [[https://www.rfc-editor.org/rfc/rfc8246.html][8246]], with the following peculiarities:

- Fetching from the cache requires a *group* to be provided (i.e. the value used to announce and look up the resource in the BitTorrent DHT, see [[file:ouinet-network-whitepaper.md::Resource groups][Resource groups]]). The group is opaque to cache control code and only passed down to custom operations.
- Cache retrieval is not assumed to always be faster than fresh retrieval, thus a cache retrieval can start a parallel fresh retrieval for the same resource (this decision can be customized).
- Responses declared private or resulting from an authorized request can be considered cacheable if explicitly told so. This enables the =cache-private= option at the client.

~CacheControl~ relies on ~ouinet::CacheEntry~ as defined in [[file:../src/cache/cache_entry.h][=src/cache/cache_entry.h=]], a simple structure representing a resource already in the cache, with a time stamp and a ~Session~ object. The header file also defines functions to derive a *local cache key* from the URL in an HTTP request, and the URL back from a key. The key is the canonical version of the URL according to [[file:../src/util.h::std::string canonical_url][~ouinet::util::canonical_url~]].

Once a ~CacheControl~ instance is created (with an executor), the following fields may be assigned custom operations:

- ~fetch_stored(request, group, cancel, yield) -> CacheEntry~ to try to fetch the cached resource in the ~request~ by looking it up under the given ~group~.
- ~fetch_fresh(request, cache_entry_ptr, cancel, yield) -> Session~ to try to fetch a fresh version of the resource in the ~request~, which may already have a cached version (if ~cache_entry_ptr~ is not null, e.g. in the case of a revalidation).
- ~parallel_fresh(request, group_opt) -> bool~ to decide whether to start a parallel fresh retrieval for the resource in the ~request~ (under the optional group ~group_opt~) while retrieving it from the cache.

After that, the [[file:../src/cache_control.h::Session fetch(const][~fetch(request, group_opt, fresh_ec, cache_ec, cancel, yield) -> Session~]] method can be called to fetch the resource in the ~request~ (under the optional group ~group_opt~) using the previous custom operations. When a stale cached response which is older than [[file:../src/cache_control.h::boost::posix_time::time_duration max_cached_age()][~max_cached_age~]] needs to be used (e.g. because a fresh one failed to be retrieved), a 110 =Warning= header is added to the response reminding about its staleness. ~fetch~ calls the private [[file:../src/cache_control.cpp::CacheControl::do_fetch(][~do_fetch~]] method, which implements all the HTTP Caching decisions and calls [[file:../src/cache_control.cpp::CacheControl::do_fetch_fresh(][~do_fetch_fresh~]] or [[file:../src/cache_control.cpp::CacheControl::do_fetch_stored(][~do_fetch_stored~]], which end up calling the custom operations above (the later taking care of the parallel fresh fetch if adequate); the running fetch fresh and stored operations are managed as ~AsyncJob~ instances held in a [[file:../src/cache_control.cpp::struct CacheControl::FetchState][~FetchState~]] structure.

The client [[file:../src/client.cpp::cc(client_state.get_executor()][creates and configures a cache control instance]], then uses it to [[file:../src/client.cpp::cc.fetch(][fetch content from the injector or the cache]] as if it was just asking a caching HTTP proxy for it.

~CacheControl~ also provides the [[file:../src/cache_control.h::static bool ok_to_cache( const http::request_header<>& request][~ok_to_cache(request, response, cache_private, reason_ptr)~]] helper function to know if it is acceptable to cache the given ~response~ to the ~request~ according to RFCs (with the aforementioned exceptions when ~cache_private~ is true), while getting the reason for the answer in ~reason_ptr~. This is used by the client to decide [[file:../src/client.cpp::&& CacheControl::ok_to_cache(][when to store a fetched response]] in its local cache.

** SSL/TLS and certificates

TODO

** BitTorrent

TODO

* Resource signing and verification

The [[file:../src/cache/http_sign.h][=src/cache/http_sign.h=]] header provides classes and functions to support Ouinet's resource signing as defined in [[file:ouinet-network-whitepaper.md::Signatures][Signatures]], including some low-level functions (used mainly for implementing signing itself but also available to other modules), high-level reader classes for easy signing and verification of HTTP responses, and low-level functions related with the generic implementation of [[https://tools.ietf.org/html/draft-cavage-http-signatures-12][HTTP Signatures]] (which serve as a base for Ouinet signatures).

The main entry points are the reader classes:

- [[file:../src/cache/http_sign.h::class SigningReader][~ouinet::cache::SigningReader~]] is used [[file:../src/injector.cpp::sig_reader = make_unique<cache::SigningReader>][by the injector]] when a client requests a signed resource from it for caching (i.e. when using the Injector request mechanism). The injector provides the connection to the origin server (as plaintext in the case of HTTPS), the request, the injection id & time stamp, and the private key used to perform the signing. The parts produced by the reader already carry signatures when appropriate (in the head, chunk headers, and trailer), and chunks have the size of data blocks.
- [[file:../src/cache/http_sign.h::class VerifyingReader][~ouinet::cache::VerifyingReader~]] is used by the client when fetching content from an untrusted source like [[file:../src/cache/http_store.cpp::return std::make_unique<VerifyingReader>][the client's static cache]]. The client provides a reader and the public key used to perform the verification of signatures. The reader produces the same parts as read, minus unsigned items (in head, chunk headers, and trailer). If the verification of some part fails, the read operation reports either ~sys::errc::no_message~ (when at the head) or ~sys::errc::bad_message~ (later on).

  Please note that responses coming straight from an injector do not need verification (as the connection is trusted). Also note that, for efficiency reasons, the fetching and verification of resources coming concurrently from several network peers is done by the multi-peer reader described in the next section.
- [[file:../src/cache/http_sign.h::class KeepSignedReader : public ouinet::http_response::AbstractReader {][~ouinet::cache::KeepSignedReader~]] is used by the client to clean from unsigned items a response already trusted (from an injector) or verified (from other peers), [[file:../src/cache/client.cpp::cache::KeepSignedReader fr(r);][right before storing it]] in its local cache, from where it can read it later without further verification.

These readers make use of ~ouinet::util::apply~ to handle the different parts that they encounter ([[file:../src/cache/http_sign.cpp::SigningReader::async_read_part][~SigningReader::async_read_part~]], [[file:../src/cache/http_sign.cpp::VerifyingReader::async_read_part][~VerifyingReader::async_read_part~]]). They also make use of the following helper classes:

- [[file:../src/cache/signed_head.h::class SignedHead][~ouinet::cache::SignedHead~]]: a subclass of ~ouinet::http_response::Head~ with functions and methods to create ([[file:../src/cache/http_sign.cpp::inh = cache::SignedHead( _rqh, std::move(inh)][usage example]]), access and verify ([[file:../src/cache/http_sign.cpp::auto head_o = cache::SignedHead::verify_and_create(std::move(inh), _pk);][usage example]]) signed HTTP heads. Also used in other modules for low-level operations.
- [[file:../src/cache/chain_hasher.h::class ChainHasher {][~ouinet::cache::ChainHasher~]]: a class which implements the computation, signing ([[file:../src/cache/http_sign.cpp::auto chain_hash = _chain_hasher.calculate_block(][usage example]]) and verification ([[file:../src/cache/http_sign.cpp::if (!chain_hash.verify(_head.public_key(), _head.injection_id()))][usage example]]) of chained hashes and signatures (see [[file:ouinet-network-whitepaper.md::Stream signatures][Stream signatures]]).

* Local and distributed storage

Ouinet's distributed cache (dcache) is implemented by clients, since injectors sign content but they do not cache it themselves. The header file [[file:../src/cache/client.h][=src/cache/client.h=]] provides the ~ouinet::cache::Client~ class, which implements all functionality for the local storage of content at the client and for sharing it with others. The [[file:../src/cache/client.h::return build(][~build~]] factory functions allow creating a cache client instance from this information:

- An executor.
- A set of UDP endpoints to listen for requests from other Ouinet clients.
- A public key to announce and lookup content in the dcache, and to verify injector signatures.
- A directory for local cache storage (see below).
- A maximum age for local cache entries (older ones will be removed automatically).
- Optional directories for a static cache and its content files (see below).
- An ~asio::yield_context~, as the build operation may take some time and spawn new coroutines.

These factory functions are used by Ouinet client code to [[file:../src/client.cpp::cache::Client::build][create its cache client]] when setting up the dcache (with or without a static cache).

Such a cache client will be able to serve content stored on-device to the Ouinet client, as well as exchange content with other clients in the same LAN. To enable exchanging content with other Ouinet clients on the Internet, the [[file:../src/cache/client.h::bool enable_dht(std::shared_ptr<bittorrent::MainlineDht>);][~enable_dht~]] method must be called with a shared pointer to an existing ~bittorrent::MainlineDht~ instance (see above). Ouinet client code also calls this method on dcache setup, [[file:../src/client.cpp::_cache->enable_dht(dht)][once the BitTorrent DHT is ready]].

** Local and static caches

The Ouinet client has a read-write *local cache* where it stores signed content coming from the injector or other clients (if it can be cached). That operation is implemented by the [[file:../src/cache/client.h::void store(][~store~]] method of ~cache::Client~, and used by Ouinet client code [[file:../src/client.cpp::cache->store(][after fetching content via a cache control instance]].

Cache client operations related with content storage are implemented by the [[file:../src/cache/http_store.h::class HttpStore][~ouinet::cache::HttpStore~]] class provided by the [[file:../src/cache/http_store.h][=src/cache/http_store.h=]] header. Besides some low-level functions, the header provides the [[file:../src/cache/http_store.h::make_http_store(fs::path][~make_http_store~]] and [[file:../src/cache/http_store.h::make_backed_http_store( fs::path][~make_backed_http_store~]] functions (invoked [[file:../src/cache/client.cpp::: make_http_store(][on cache client creation]]), which respectively return an ~HttpStore~ instance relying either on just a local cache, or on a local cache plus a static cache. They both create a new local cache if missing in the given path.

The *static cache* is read-only. If used, the (so-called "backed") HTTP store tries to read content from the local cache first, and failing that from the static cache. Store operations are always sent to the local cache only. The [[file:../src/cache/http_store.h::make_static_http_store( fs::path][~make_static_http_store~]] function (also invoked [[file:../src/cache/client.cpp::static_http_store = make_static_http_store(][on cache client creation]]) returns an instance of such store, which lacks write operations.

The cache client provides the [[file:../src/cache/client.h::std::size_t local_size(][~local_size~]] method to compute the combined size of the client cache (local + static), and the [[file:../src/cache/client.h::void local_purge( Cancel][~local_purge~]] method to empty the local cache completely (using the [[file:../src/cache/http_store.h::for_each(keep_func][~HttpStore::for_each~]] method); both are used by the client front-end (see further below). Finally, the cache client also runs a [[file:../src/cache/client.cpp::struct GarbageCollector][garbage collector]] which iterates periodically over all local cache entries (again using ~HttpStore::for_each~) and invokes a [[file:../src/cache/client.cpp::bool keep_cache_entry(][function]] to determine whether the entry should be kept or removed (e.g. if invalid or past its maximum age).

*** HTTP store format

Both local and static caches share the same on-disk format for storing signed HTTP content. The HTTP store sits in a =data-v<N>= subdirectory of the cache directory (in the ~cache::Client::build~ call, the ~cache_dir~ argument for local and ~static_cache_dir~ for static cache; in ~make*_http_store~, the ~path~ argument), where =N= is the version number of the store format. In the case of the static cache, some HTTP store entries may not contain the actual content data, and they may instead point to files under a *static cache content root* (in ~cache::Client::build~, ~static_cache_content_dir~; in ~make_static_http_store~, ~content_path~), which may have an arbitrary location.

For version 3 of the HTTP store, each resource with a given cache =KEY= (being the canonical version of its URL as indicated in [[*Cache control][Cache control]]) having =lowercase_hex(sha1(<KEY>)) = xyzzzz…=, is saved as a set of files under the subdirectory =xy/zzzz…=, to avoid having too many entries in the same store directory.

For storing resources coming from the injector or other clients into the local cache, this is implemented by the [[file:../src/cache/http_store.cpp::FullHttpStore::store(][~FullHttpStore::store~]] method from a reader and a key, using the (private) [[file:../src/cache/http_store.cpp::path_from_key(fs::path dir, const std::string& key)][~path_from_key~]] function to compute the storage subdirectory, and the [[file:../src/cache/http_store.cpp::http_store( http_response::AbstractReader&][~ouinet::cache::http_store~]] function to save the response to it; the later uses the [[file:../src/cache/http_store.cpp::class SplittedWriter][~SplittedWriter~]] class to process the different parts of the response and save them appropriate files to the directory.

The directory for the particular resource contains the following files:

- =head=: the raw, signed HTTP head. The head of an incomplete response (e.g. from an aborted exchange with an injector) usually has an ~X-Ouinet-Sig0~ header and no ~X-Ouinet-Data-Size~ or ~Digest~ headers; when the response is complete, ~SplittedWriter~ merges the relevant trailer fields (if any) into the head, replacing ~X-Ouinet-Sig0~ with ~X-Ouinet-Sig1~ and adding the ~X-Ouinet-Data-Size~ and ~Digest~ headers.
- =body=: the plain data in the response body (without chunk delimiters). This may be missing if the resource has an empty or missing body. In the case of a static cache, this file may be replaced by a =body-path= file containing the path of the body data file, relative to the static cache content root.
- =sigs=: the block signatures and chained hashes for each block of data in the response body, one line per block.

More detailed information about the format of each file can be found in the documentation of the [[file:../src/cache/http_store.h::void http_store( http_response::AbstractReader&][~ouinet::cache::http_store~]] function.

For loading resources from the client cache, the cache client implements a private [[file:../src/cache/client.cpp::Session load_from_local(][~load_from_local~]] function which makes use of the HTTP store's [[file:../src/cache/http_store.h::reader(const std::string&][~reader~]] and [[file:../src/cache/http_store.h::reader_and_size(const std::string&][~reader_and_size~]] methods, which end up calling the private [[file:../src/cache/http_store.cpp::_http_store_reader( const fs::path& dirp, boost::optional<const fs::path&> cdirp][~_http_store_reader~]] function. The later opens the needed storage files and builds an [[file:../src/cache/http_store.cpp::class HttpStoreReader][~HttpStoreReader~]], which takes care of reassembling the HTTP response in a way which can be consumed by a user agent, but also preserves all signatures for further sharing.

** Peer-to-peer content sharing

TODO The cache client provides the [[file:../src/cache/client.h::Session load(][~load~]] method which looks up the client cache and the DHT, using [[file:../src/cache/multi_peer_reader.h::class MultiPeerReader][~ouinet::cache::MultiPeerReader~]].

TODO General operation of ~MultiPeerReader~: lookup group of resource in DHT, request resource head from peers using =PROPFIND= (which yields block signatures and hashes as its body, see [[file:../src/cache/hash_list.h::struct HashList {][~ouinet::cache::HashList~]]), choose the most recently injected version, request body blocks from peers having them using HTTP range requests.

TODO Each group under the =dht_groups= in the cache directory (local or static) is [[file:../src/cache/announcer.h::class Announcer][announced]] to the BitTorrent DHT (with keys constructed as per [[file:ouinet-network-whitepaper.md::Resource groups][Resource groups]]). See documentation for ~REPO_DIR_INFO~ in https://github.com/equalitie/ouinet-inject/blob/master/ouinet/inject.py.

TODO For serving cached content to other clients, the cache client provides the [[file:../src/cache/client.h::bool serve_local(][~serve_local~]] method, which handles =PROPFIND= (using [[file:../src/cache/http_store.h::load_hash_list(const std::string&][~HttpStore::load_hash_list~]]), =HEAD= and =GET= requests (with or without ranges).

TODO

* Client and injector

TODO


# Local Variables:
# mode: org
# mode: visual-fill-column
# mode: visual-line
# mode: flyspell
# ispell-local-dictionary: "american"
# End:
