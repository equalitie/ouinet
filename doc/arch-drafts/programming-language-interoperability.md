# Ouinet programming language interoperability

* *Document version:* 0.1.0
* *Last update:* February, 2024

## 0. Overview

This document aims to clarify the current status of the library in terms of cross-language integration and possible improvements. The challenges and goals resulting from the analysis are organized in three different sections:

1. Using Ouinet libraries with other programming languages
2. Using libraries from other programming languages in Ouinet
3. Ouinet refactoring strategy

The sources used as a reference for this plan are stored in [gitlab.com/equalitie/ouinet.git](https://gitlab.com/equalitie/ouinet.git) and consists of around 22 thousand lines of C++ code with the following distribution:

### Lines of code analysis

| Language              |     files       |  blank       | comment      |   code  |
|-----------------------|-----------------|--------------|--------------|---------|
| C++                   |         94      |    5200      |    1770      |   21981 |
| C/C++ Header          |        146      |    3332      |    1585      |   11822 |
| CMake                 |         22      |     199      |     123      |    1241 |
| Kotlin                |          7      |      86      |      20      |     801 |
| Java                  |          3      |      96      |      99      |     782 |
| Python                |          7      |     251      |     259      |     706 |
| Bourne Shell          |          9      |     125      |     123      |     629 |
| Go                    |          1      |      85      |      45      |     283 |

### C++ standard support

The base code Ouinet's core supports C++ 17 but some dependencies are still building with 11 or 14 standard.

| module      | standard      |
|-------------|---------------|
| ouinet-base | c++1z / c++17 |
| boost       | c++14         |
| i2pd        | c++11         |


## 1. Using Ouinet libraries with other programming languages

### Current JNI implementation

There's already an integration [with Android](https://gitlab.com/equalitie/ouinet/-/tree/main/android) that uses JNI to expose a `Config` builder and a `Client` class to Java and Kotlin applications.

Based on this implementation we've identified the following methods that are enough to interact with the Ouinet service; `Start`, and `Stop` to control the Client, `GetStatus` to monitor it, and an optional method to retrieve the TLS certificates root defined in Ouinet's conf file `GetCARootCert`.

* Client control:

```
StartClient
StopClient
```

* Client monitoring:
```
GetClientState
```

* Utilities:
```
GetCARootCert
```

Some attributes related to the Client wrapper are also exposed and can be classified in 5 groups; `General`, `Logging`, `Injector`, `BEP5 Cache` and `Request mechanism`

* General:

```
String frontEndEp
String listenOnTcp
String localDomain
String maxCachedAge
String originDohBase
String ouinetDirectory
```

* Logging:

```
boolean enableLogFile
LogLevel logLevel
```

* Injector:

```
String injectorCredentials
String injectorTlsCert
String injectorTlsCertPath
String caRootCertPath
String tlsCaCertStorePath
```

* BEP5 Cache:

```
boolean cachePrivate
String cacheHttpPubKey
String cacheStaticContentPath
String cacheStaticPath
String cacheType
Set<String> btBootstrapExtras
```

* Request mechanism:

```
boolean disableBridgeAnnouncement
boolean disableInjectorAccess
boolean disableOriginAccess
boolean disableProxyAccess
```

### C API

Considering that most of the FFI mechanisms available are based on the linking of C-like methods and variables, it'd be useful to expose first a Ouinet C API that contains the main control methods and the attributes needed to use the service. This API should be flexible enough to be reused by the Rust and the Golang bindings. It's not mandatory but desirable that this API should be also compatible with the binding generator tools (e.g. [SWIG](https://www.swig.org)) for other high level languages like Python or Ruby.

An useful experiment to define the structure of this API would be to create a small C++ application and integrate Ouinet libraries, this exercise will clarify the usability of the current public libraries before exposing them to other languages.


### Python bindings

Ouinet makes use of Boost libraries so using [Boost.Python](https://www.boost.org/doc/libs/1_77_0/libs/python/) could help us to have a simple and consistent exposure of the new bindings.

One of the main problems to solve if we follow this approach is that Ouinet builds Boost statically which is incompatible with the resulting shared objects generated by the binding targets. Removing this blocker should be the first task before starting with the exposure of the wrapper objects and attributes.

Tasks:

- Solve problems related to build `Boost.Python` with static Boost libraries or use an alternative like `SWIG`.
- Modify CMake scripts to build the targets.
- Package bindings, create a setup tools script and simplify its install.
- Test the bindings with threads and co-routines.
- Perform an example integration with a Python application or service.


### Rust via FFI

Rust has support for integrating C libraries into Rust programs via `extern`. A similar integration with C++ could be achieved using the same [FFI](https://doc.rust-lang.org/std/ffi/) capabilities and using `extern` on the C++ side to generate C header files that can be used with Rust.

The most challenging part of this integration would be to deal with memory management and throwing errors and exceptions on the C++, these particular aspects be carefully covered by the automated tests.

Tasks:

- Extern the objects and attributes needed to C header libraries.
- Modify CMake files in Ouinet to automatically build the C `.h` files.
- Import the C headers in Rust.
- Implement the error handling mechanism on the Rust side.
- Check the feasibility of packaging it as crate.
- Perform an example integration with a Rust application or service.


### Golang via FFI

[cgo](https://pkg.go.dev/runtime/cgo) is one of the most used packages in Golang to interface with C/C++ libraries. Similarly to the Rust workflow we will rely on the C API to implement the required handlers to pass values between both languages via FFI.

Tasks:

- Extern the objects and attributes needed to C header libraries.
- Implement cgo handlers to use the C++ library.
- Check the feasibility of packaging it.
- Perform an example integration with a Golang application or service.


## 2. Using libraries from other programming languages in Ouinet

The main purpose of reusing the code generated by similar applications is to make our Ouinet base code more stable and easier to maintain. One of the main integration targets is [btdht](https://github.com/equalitie/btdht) package, written in Rust for the Ouisync project.

### Rust

[cbindgen](https://crates.io/crates/cbindgen) is a good candidate to automatically generate C headers that can be used on the Ouinet C++ base code. We will use Ouisync's btdht as an integration proof of concept.

Tasks:

- Define the public API that will be externalized.
- Add `cbindgen` to the Cargo targets.
- Modify CMake scripts on Ouinet's side to get the `btdht` crate.
- Build a C++ test program to use the DHT.

### Golang

We have already an integration example in Ouinet. The `OuiService` interface has an implementation of `LampShade` and expose its [bindings](https://gitlab.com/equalitie/ouinet/-/tree/main/src/ouiservice/lampshade/lampshade_bindings) to C++ via `cgo`.

Tasks:

- Choose a Golang package that could be interesting for Ouinet.
- Define the public API that will be externalized.
- Use `cgo` to expose the API to C++.
- Modify Ouinet CMake scripts to build the package.
- Build a C++ test program to use the package.


## 3. Ouinet refactoring strategy

One of the main benefits of reusing libraries from Rust and Golang is the possibility of gradually refactoring Ouinet, starting by the components that add more complexity or those that are most difficult to maintain.

This section offers an overview of the main Ouinet components and also defines possible targets to start the refactoring. It's important to mention that some of the current components could be splitted or removed during the refactoring process as the redesing could alse benefit from changes to the code structure as long as the specs defined in the whitepaper are met.


### Main components

The following list points to the main Ouinet components classified and organized from a functionality perspective. The purpose of this section is to have a catalog of components that would be necesary to port (or implement from scratch) in order to be compatible with Ouinet specs defined in the white paper.

- [Client](https://gitlab.com/equalitie/ouinet/-/blob/main/src/client.h)
- [Injector](https://gitlab.com/equalitie/ouinet/-/blob/main/src/injector.cpp)
- [BitTorrent](https://gitlab.com/equalitie/ouinet/-/blob/main/src/bittorrent/)
    - [Announcer](https://gitlab.com/equalitie/ouinet/-/blob/main/src/bittorrent/bep5_announcer.h)
    - [Bootstrap](https://gitlab.com/equalitie/ouinet/-/blob/main/src/bittorrent/bootstrap.h)
    - [DHT](https://gitlab.com/equalitie/ouinet/-/blob/main/src/bittorrent/dht.h)
    - [Routing table](https://gitlab.com/equalitie/ouinet/-/blob/main/src/bittorrent/routing_table.h)
- [Cache control](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/)
    - [Announcer](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/announcer.h)
    - [DHT Lookup](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/dht_lookup.h)
    - [Client](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/client.h)
    - [HTTP Sign](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/http_sign.h)
    - [HTTP Store](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/http_store.h)
    - [Local Peer Discovery](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/local_peer_discovery.h)
    - [Multi Peer Reader](https://gitlab.com/equalitie/ouinet/-/blob/main/src/cache/multi_peer_reader.h)
- [OuiService](https://gitlab.com/equalitie/ouinet/-/blob/main/src/ouiservice/)
    - [BEP5](https://gitlab.com/equalitie/ouinet/-/tree/main/src/ouiservice/bep5)
    - [i2p](https://gitlab.com/equalitie/ouinet/-/tree/main/src/ouiservice/i2p)
    - [Multi uTP Server](https://gitlab.com/equalitie/ouinet/-/blob/main/src/ouiservice/multi_utp_server.h)
    - [TCP](https://gitlab.com/equalitie/ouinet/-/blob/main/src/ouiservice/tcp.h)
    - [TLS](https://gitlab.com/equalitie/ouinet/-/blob/main/src/ouiservice/tls.cpp)
    - [uTP](https://gitlab.com/equalitie/ouinet/-/blob/main/src/ouiservice/utp.h)
- [SSL](https://gitlab.com/equalitie/ouinet/-/tree/main/src/ssl)
- [Util](https://gitlab.com/equalitie/ouinet/-/tree/main/src/util)
- [Android bindings](https://gitlab.com/equalitie/ouinet/-/tree/main/android)
    - [JNI Kotlin/Java](https://gitlab.com/equalitie/ouinet/-/tree/main/android/ouinet/src/main)
- [Third Party](https://gitlab.com/equalitie/ouinet/-/tree/main/modules)
    - [Asio uTP](https://gitlab.com/equalitie/asio-utp)
    - [CPP UPnP](https://gitlab.com/equalitie/cpp-upnp)
    - [i2pd](https://gitlab.com/equalitie/i2pd)

### Candidates for refactoring

1. Considering that the functionality of the BEP5 DHT is critical in the current implementation of Ouinet this component appears in the top of the list of components to refactor. Processes using the DHT are complex and difficult to optimize and maintain, reusing [btdht](https://github.com/equalitie/btdht) could improve the performance and reduce the amount of time to find and fix bugs.

2. DNS over HTTPS is implemented but not optimized, as the feature is not actively used becomes a good candidate to implement with a well maintained library like [doh-server](https://github.com/DNSCrypt/doh-server).

3. The HTTP Proxy which could be implemented with a custom crate that relies on the native Rust library `http` and a crate for dealing with the TLS encryption.

### Prerequisites of the refactoring

- Estimate the time needed to peform a refactoring when most of the tasks from sections 1 and 2 of the current plan are complete.
- Define team capacity, goals and schedule the milestones.
- Make sure that the integration and acceptance test suites are complete and stable before starting any refactoring.
- Establish quality and performance metrics that should be fulfilled by the ported components.
- Plan the releases containing refactoring.

## References

* [Kauffman, M. (2011), API Design for C++, Martin Reddy](https://books.google.com.mx/books/about/API_Design_for_C++.html?id=IY29LylT85wC)
* [Stevanovic, M. (2014), Advanced C and C++ Compiling, Appress](https://link.springer.com/book/10.1007/978-1-4302-6668-6)
* [The rustonomicon. FFI](https://doc.rust-lang.org/nomicon/ffi.html)
* [RustConf 2018 - Embedding Rust in C/C++ by Katharina](https://www.youtube.com/watch?v=x9acx2zgx4Q)
* [Hunger, T. (November 11, 2022), Rust and C++ Interoperability](https://slint.dev/blog/rust-and-cpp)


